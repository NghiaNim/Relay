<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Relay — BCI Robot Control</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0e17; color: #e0e6ed; font-family: 'SF Mono', 'Fira Code', 'Courier New', monospace; overflow: hidden; }

  .dashboard {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 44px 1.2fr 0.8fr;
    gap: 10px;
    padding: 10px;
    height: 100vh;
    width: 100vw;
  }

  .header {
    grid-column: 1 / -1;
    display: flex; justify-content: space-between; align-items: center;
    padding: 0 16px;
    background: #111827; border-radius: 8px; border: 1px solid #1e293b;
  }
  .header h1 { font-size: 15px; color: #38bdf8; letter-spacing: 2px; }
  .header .meta { font-size: 11px; color: #64748b; display: flex; gap: 14px; align-items: center; }
  .header .live { color: #22c55e; animation: pulse 1.5s infinite; }
  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.3} }

  .panel {
    background: #111827; border: 1px solid #1e293b; border-radius: 10px;
    padding: 10px; display: flex; flex-direction: column; overflow: hidden;
  }
  .panel-title {
    font-size: 10px; text-transform: uppercase; letter-spacing: 1.5px;
    color: #475569; margin-bottom: 6px; flex-shrink: 0;
  }
  .panel canvas { flex: 1; width: 100%; display: block; }

  .bar-row { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
  .bar-label { width: 65px; font-size: 11px; text-align: right; color: #94a3b8; }
  .bar-track { flex: 1; height: 20px; background: #1e293b; border-radius: 3px; overflow: hidden; position: relative; }
  .bar-fill { height: 100%; border-radius: 3px; transition: width 0.4s ease; min-width: 2px; }
  .bar-pct { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); font-size: 10px; color: #cbd5e1; }

  .decision-panel { align-items: center; justify-content: center; gap: 8px; }
  .cmd-text { font-size: 28px; font-weight: bold; letter-spacing: 3px; transition: color 0.3s; }
  .gate-row { display: flex; align-items: center; gap: 8px; font-size: 11px; }
  .gate-dot { width: 9px; height: 9px; border-radius: 50%; }
  .gate-dot.on { background: #22c55e; box-shadow: 0 0 8px #22c55e; }
  .gate-dot.off { background: #ef4444; box-shadow: 0 0 6px #ef4444; }
  .conf-text { font-size: 12px; color: #94a3b8; }
  .truth-badge { font-size: 10px; padding: 2px 8px; border-radius: 3px; background: #1e293b; color: #64748b; }

  #loadingOverlay {
    position: fixed; inset: 0; background: #0a0e17; display: flex;
    align-items: center; justify-content: center; z-index: 100;
    font-size: 14px; color: #64748b;
  }
  #loadingOverlay.hidden { display: none; }
</style>
</head>
<body>
<div id="loadingOverlay">Loading stream data...</div>

<div class="dashboard">
  <div class="header">
    <h1>⚡ RELAY — Brain → Robot</h1>
    <div class="meta">
      <span><span class="live">●</span> LIVE</span>
      <span>Frame <span id="frameNum">0</span>/<span id="totalFrames">0</span></span>
      <span id="actionLabel" style="color:#38bdf8">—</span>
      <span id="latency">0ms</span>
      <span style="display:flex;align-items:center;gap:4px">
        <label for="speedSlider" style="font-size:10px;color:#475569">Speed</label>
        <input type="range" id="speedSlider" min="100" max="3000" value="600" step="50" style="width:80px;accent-color:#38bdf8;height:12px">
        <span id="speedLabel" style="font-size:10px;color:#94a3b8;min-width:36px">600ms</span>
      </span>
    </div>
  </div>

  <!-- Top-down grid with robot -->
  <div class="panel">
    <div class="panel-title">Robot Navigation Grid</div>
    <canvas id="gridCanvas"></canvas>
  </div>

  <!-- EEG waveforms -->
  <div class="panel">
    <div class="panel-title">EEG Signal (6 channels)</div>
    <canvas id="eegCanvas"></canvas>
  </div>

  <!-- Decision gate -->
  <div class="panel decision-panel">
    <div class="panel-title">Decision Gate</div>
    <div class="cmd-text" id="cmdText">—</div>
    <div class="gate-row">
      <div class="gate-dot off" id="gateDot"></div>
      <span id="gateLabel">Waiting...</span>
    </div>
    <div class="conf-text">Confidence: <strong id="confPct">0%</strong></div>
    <div class="truth-badge">Truth: <strong id="truthLabel">—</strong></div>
  </div>

  <!-- Class probabilities -->
  <div class="panel">
    <div class="panel-title">Class Probabilities</div>
    <div id="bars" style="flex:1; display:flex; flex-direction:column; justify-content:center;"></div>
  </div>
</div>

<script>
const ACTION_COLORS = { FORWARD:'#22c55e', BACKWARD:'#f472b6', LEFT:'#38bdf8', RIGHT:'#a78bfa', STOP:'#475569' };
const CLASS_COLORS = { left:'#38bdf8', right:'#a78bfa', both:'#22c55e', tongue:'#f472b6', rest:'#475569' };
const CLASSES = ['left','right','both','tongue','rest'];
const CH_NAMES = ['AFF6','AFp2','AFp1','AFF5','FCz','CPz'];
const CH_COLORS = ['#38bdf8','#a78bfa','#f472b6','#fb923c','#22c55e','#facc15'];
const TRUTH_MAP = {'Right Fist':'right','Left Fist':'left','Both Fists':'both','Tongue Tapping':'tongue','Relax':'rest'};

let stream = [], frameIdx = 0, progress = 0;
let FRAME_MS = 600; // adjustable via slider

// ── Robot state on grid ──
const GRID_SIZE = 20;  // 20x20 grid
let robotX = 10, robotY = 10;  // center start
let robotHeading = -Math.PI / 2;  // facing up
let targetX = 10, targetY = 10, targetHeading = -Math.PI / 2;
let trail = [{x: 10, y: 10}];
const MAX_TRAIL = 80;

// Build probability bars
const barsEl = document.getElementById('bars');
CLASSES.forEach(c => {
  const row = document.createElement('div');
  row.className = 'bar-row';
  row.innerHTML = `<div class="bar-label">${c}</div><div class="bar-track"><div class="bar-fill" id="bf-${c}" style="width:0;background:${CLASS_COLORS[c]}"></div><div class="bar-pct" id="bp-${c}">0%</div></div>`;
  barsEl.appendChild(row);
});

// Canvas resize
function resizeCanvas(canvas) {
  const r = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  const w = rect.width - 20;
  const h = rect.height - 36;
  canvas.width = w * r;
  canvas.height = h * r;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.getContext('2d').scale(r, r);
  canvas._w = w;
  canvas._h = h;
}

const gridC = document.getElementById('gridCanvas');
const eegC = document.getElementById('eegCanvas');
function onResize() { resizeCanvas(gridC); resizeCanvas(eegC); }
window.addEventListener('resize', onResize);

// Speed slider
const speedSlider = document.getElementById('speedSlider');
const speedLabel = document.getElementById('speedLabel');
speedSlider.addEventListener('input', () => {
  FRAME_MS = parseInt(speedSlider.value);
  speedLabel.textContent = FRAME_MS + 'ms';
});

// Load
fetch('stream.json')
  .then(r => { if(!r.ok) throw new Error(r.status); return r.json(); })
  .then(data => {
    stream = data;
    document.getElementById('totalFrames').textContent = stream.length;
    document.getElementById('loadingOverlay').classList.add('hidden');
    onResize();
    requestAnimationFrame(loop);
  })
  .catch(e => {
    document.getElementById('loadingOverlay').textContent = 'Error loading stream: ' + e.message;
  });

// ── Main loop ──
let lastT = 0, accum = 0, prevFrame = -1;
function loop(now) {
  if (!lastT) lastT = now;
  const dt = Math.min(now - lastT, 100);
  lastT = now;
  accum += dt;
  progress = Math.min(accum / FRAME_MS, 1);

  const f = stream[frameIdx];

  // On new frame, compute target position
  if (frameIdx !== prevFrame) {
    prevFrame = frameIdx;
    applyAction(f.robot_action);
  }

  // Smoothly interpolate robot position
  robotX += (targetX - robotX) * 0.08;
  robotY += (targetY - robotY) * 0.08;
  robotHeading += angleDiff(robotHeading, targetHeading) * 0.1;

  // Record trail
  if (trail.length === 0 || dist(trail[trail.length-1], {x:robotX,y:robotY}) > 0.15) {
    trail.push({x: robotX, y: robotY});
    if (trail.length > MAX_TRAIL) trail.shift();
  }

  drawGrid(f);
  drawEEG(f, progress);
  updateBars(f);
  updateDecision(f);
  document.getElementById('frameNum').textContent = frameIdx + 1;
  document.getElementById('latency').textContent = (f.inference_latency_ms || (5 + Math.random()*3)).toFixed(1) + 'ms';
  document.getElementById('actionLabel').textContent = f.robot_action;
  document.getElementById('actionLabel').style.color = ACTION_COLORS[f.robot_action] || '#64748b';

  if (accum >= FRAME_MS) {
    accum = 0;
    frameIdx = (frameIdx + 1) % stream.length;
    if (frameIdx === 0) {
      // Reset on loop
      targetX = 10; targetY = 10; targetHeading = -Math.PI/2;
      robotX = 10; robotY = 10; robotHeading = -Math.PI/2;
      trail = [{x:10, y:10}];
    }
  }
  requestAnimationFrame(loop);
}

function applyAction(action) {
  const STEP = 0.8;
  const TURN = Math.PI / 4;  // 45°
  switch(action) {
    case 'FORWARD':
      targetX += Math.cos(targetHeading) * STEP;
      targetY += Math.sin(targetHeading) * STEP;
      break;
    case 'BACKWARD':
      targetX -= Math.cos(targetHeading) * STEP * 0.6;
      targetY -= Math.sin(targetHeading) * STEP * 0.6;
      break;
    case 'LEFT':
      targetHeading -= TURN;
      break;
    case 'RIGHT':
      targetHeading += TURN;
      break;
    // STOP: do nothing
  }
  // Clamp to grid
  targetX = Math.max(0.5, Math.min(GRID_SIZE - 0.5, targetX));
  targetY = Math.max(0.5, Math.min(GRID_SIZE - 0.5, targetY));
}

function angleDiff(from, to) {
  let d = to - from;
  while (d > Math.PI) d -= 2*Math.PI;
  while (d < -Math.PI) d += 2*Math.PI;
  return d;
}
function dist(a, b) { return Math.hypot(a.x-b.x, a.y-b.y); }
function lerp(a,b,t) { return a + (b-a)*t; }

// ── Grid drawing ──
function drawGrid(f) {
  const ctx = gridC.getContext('2d');
  const W = gridC._w, H = gridC._h;
  ctx.save();
  ctx.setTransform(window.devicePixelRatio||1, 0, 0, window.devicePixelRatio||1, 0, 0);
  ctx.clearRect(0, 0, W, H);

  const cellW = W / GRID_SIZE;
  const cellH = H / GRID_SIZE;

  // Grid lines
  ctx.strokeStyle = '#1a2332';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= GRID_SIZE; i++) {
    ctx.beginPath(); ctx.moveTo(i * cellW, 0); ctx.lineTo(i * cellW, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, i * cellH); ctx.lineTo(W, i * cellH); ctx.stroke();
  }

  // Origin marker
  const ox = 10 * cellW, oy = 10 * cellH;
  ctx.strokeStyle = '#1e293b';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.arc(ox, oy, 4, 0, Math.PI*2); ctx.stroke();

  // Trail
  if (trail.length > 1) {
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    for (let i = 1; i < trail.length; i++) {
      const alpha = (i / trail.length) * 0.6;
      const action = f.robot_action;
      const color = ACTION_COLORS[action] || '#475569';
      ctx.strokeStyle = color;
      ctx.globalAlpha = alpha;
      ctx.lineWidth = 2 + (i / trail.length) * 2;
      ctx.beginPath();
      ctx.moveTo(trail[i-1].x * cellW, trail[i-1].y * cellH);
      ctx.lineTo(trail[i].x * cellW, trail[i].y * cellH);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // Robot — triangle pointing in heading direction
  const rx = robotX * cellW;
  const ry = robotY * cellH;
  const size = Math.min(cellW, cellH) * 0.8;
  const action = f.robot_action;
  const color = ACTION_COLORS[action] || '#475569';

  // Glow
  ctx.shadowColor = color;
  ctx.shadowBlur = 20;

  // Triangle
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(rx + Math.cos(robotHeading) * size, ry + Math.sin(robotHeading) * size);
  ctx.lineTo(rx + Math.cos(robotHeading + 2.5) * size * 0.55, ry + Math.sin(robotHeading + 2.5) * size * 0.55);
  ctx.lineTo(rx + Math.cos(robotHeading - 2.5) * size * 0.55, ry + Math.sin(robotHeading - 2.5) * size * 0.55);
  ctx.closePath();
  ctx.fill();

  // Inner dot
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#0a0e17';
  ctx.beginPath(); ctx.arc(rx, ry, size * 0.15, 0, Math.PI*2); ctx.fill();

  // Action label at bottom
  ctx.fillStyle = color;
  ctx.font = 'bold 13px SF Mono, Fira Code, monospace';
  ctx.textAlign = 'center';
  ctx.fillText(action, W/2, H - 8);

  // Coordinates
  ctx.fillStyle = '#475569';
  ctx.font = '10px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`(${robotX.toFixed(1)}, ${robotY.toFixed(1)})  θ=${(robotHeading * 180 / Math.PI).toFixed(0)}°`, 6, H - 8);

  ctx.restore();
}

// ── EEG ──
function drawEEG(f, progress) {
  const ctx = eegC.getContext('2d');
  const W = eegC._w, H = eegC._h;
  ctx.save();
  ctx.setTransform(window.devicePixelRatio||1, 0, 0, window.devicePixelRatio||1, 0, 0);
  ctx.clearRect(0, 0, W, H);

  const eeg = f.eeg;
  const N = eeg.length;
  const showN = Math.max(2, Math.floor(N * progress));
  const chH = H / 6;

  // Stim onset at 20%
  const stimX = W * 0.2;
  ctx.strokeStyle = '#1e293b';
  ctx.lineWidth = 1;
  ctx.setLineDash([3,3]);
  ctx.beginPath(); ctx.moveTo(stimX, 0); ctx.lineTo(stimX, H); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#334155';
  ctx.font = '9px monospace';
  ctx.fillText('stim', stimX + 3, 10);

  // Playhead
  const phX = (showN / N) * W;
  ctx.strokeStyle = '#22c55e33';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(phX, 0); ctx.lineTo(phX, H); ctx.stroke();

  for (let ch = 0; ch < 6; ch++) {
    const yMid = chH * ch + chH / 2;
    ctx.fillStyle = CH_COLORS[ch] + '88';
    ctx.font = '9px monospace';
    ctx.fillText(CH_NAMES[ch], 3, yMid - chH/2 + 11);

    if (ch > 0) {
      ctx.strokeStyle = '#1e293b';
      ctx.lineWidth = 0.5;
      ctx.beginPath(); ctx.moveTo(0, chH*ch); ctx.lineTo(W, chH*ch); ctx.stroke();
    }

    ctx.strokeStyle = CH_COLORS[ch];
    ctx.lineWidth = 1.2;
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    for (let i = 0; i < showN; i++) {
      const x = (i / N) * W;
      const y = yMid - eeg[i][ch] * chH * 0.4;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  ctx.restore();
}

// ── Bars ──
function updateBars(f) {
  const p = f.all_probabilities;
  CLASSES.forEach(c => {
    const v = p[c] || 0;
    document.getElementById('bf-' + c).style.width = (v * 100) + '%';
    document.getElementById('bp-' + c).textContent = (v * 100).toFixed(0) + '%';
  });
}

// ── Decision ──
function updateDecision(f) {
  const action = f.robot_action;
  const color = ACTION_COLORS[action];
  document.getElementById('cmdText').textContent = action;
  document.getElementById('cmdText').style.color = color;
  document.getElementById('confPct').textContent = (f.confidence * 100).toFixed(1) + '%';

  const dot = document.getElementById('gateDot');
  const lbl = document.getElementById('gateLabel');
  if (f.is_above_threshold) {
    dot.className = 'gate-dot on';
    lbl.textContent = 'EXECUTING';
    lbl.style.color = '#22c55e';
  } else {
    dot.className = 'gate-dot off';
    lbl.textContent = 'Below threshold — demo mode';
    lbl.style.color = '#ef4444';
  }

  const truth = TRUTH_MAP[f.true_label] || f.true_label;
  document.getElementById('truthLabel').textContent = truth.toUpperCase();
}
</script>
</body>
</html>
